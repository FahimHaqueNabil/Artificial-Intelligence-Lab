# -*- coding: utf-8 -*-
"""gas_pump.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WEy26XFxuKXFz9aGasG1JItuNetEprWK
"""

import numpy as np
np.random.seed(10)
reg_arr=[]
pol_arr=[]

class SSQ:
  def __init__(self):   #Initialization

    self.reg_interarrivals= list(np.random.exponential(scale=5.6, size=333)) # Edit size as necessary
    self.pol_interarrivals= list(np.random.uniform(low=30, high=30, size=166)) # Edit size as necessary
    reg_arr.append(self.reg_interarrivals[0])
    pol_arr.append(15)
    self.next_pol_arrival = 15
    self.next_arrival=self.reg_interarrivals[0]
    self.cal_reg_arrival()
    self.call_pol_arrival()
    #self.interarrivals= list(np.random.exponential(scale=5, size=50)) # Edit size as necessary
    #self.next_arrival=self.reg_interarrivals.pop(0)
    self.service_times= list(np.random.exponential(scale=4.8, size=500)) # Edit size as necessary
    # print(self.reg_interarrivals[0])
    # print(self.reg_interarrivals)
    # print(self.pol_interarrivals)
    # print(self.service_times)

    self.clock= 0.0
    
   # self.next_arrival=self.reg_interarrivals.pop(0)
    self.next_departure= float('inf')
    self.p_count = 0
    self.r_count = 0
    self.p2_count = 0
    self.num_in_queue= 0
    self.times_of_arrival_in_queue= []         #store times of arrivals who are waiting in the queue
    self.service_times_in_queue= []   #store service times of waiting customers in the queue
    
    self.total_delay=0.0
    self.num_of_delays= 0.0
    self.area_under_q= 0.0
    #self.area_under_b= 0.0
    self.idle_time = 0.0
    
    self.server_status= 0        # 0 for IDLE , 1 for BUSY
    self.last_event_time=0.0     # we will need to store last event clock time 
    self.last_departure = 0.0



  def start(self):
    while self.num_of_delays<=150: # Set termination condition as necessary
      previous_time = self.clock
      self.simulate_next_event()
      time_difference = self.clock - previous_time
      self.area_under_q += self.num_in_queue * time_difference
      #print("Area Under Q: "+ str(self.area_under_q))
      print(" ")

    if self.num_of_delays > 150:
      avg = self.total_delay/150

    

    #expected_customer_num = str(self.area_under_q / self.last_event_time)
    expected_utilization = ((self.last_event_time - self.idle_time)/self.last_event_time)*100

    print("Average Delay: "+ str(avg))
    #print("Expected number of customers in queue: " + str(expected_customer_num))
    print("Expected Utilization of the server: "+ str(expected_utilization) + '%')
    
  
  def simulate_next_event(self):
    self.clock= min(self.next_arrival,self.next_departure)  #First set clock to minimum time of next event

    if self.next_arrival<= self.next_departure:
      self.arrival()
      print("Arrival at Clock:" +str(self.clock))
    
    else:
      self.departure()
      print("Departure at "+str(self.clock))
    
    print("Server Status:"+str(self.server_status))
    print("Times of arrivals in Queue: "+ str(self.times_of_arrival_in_queue))
    print("Service times in Queue: "+str(self.service_times_in_queue))
    print("Total Delay:" +str(self.total_delay))
    print("Next Arrival Time: "+str(self.next_arrival))
    print("Next Departure Time: "+str(self.next_departure))
    

    self.last_event_time = self.clock 

  def call_pol_arrival(self):
    for i in range(len(self.pol_interarrivals)):
      self.next_pol_arrival= self.next_pol_arrival+ self.pol_interarrivals[i]  
      pol_arr.append(self.next_pol_arrival)
    #print("POL:"+str(pol_arr))

  def cal_reg_arrival(self):
    for i in range(len(self.reg_interarrivals)):
      if i == 0:
        continue
      else:  
        self.next_arrival= self.next_arrival+ self.reg_interarrivals[i]  
        reg_arr.append(self.next_arrival)
    # print("REG:"+str(reg_arr[0]))    
    # print("REG:"+str(reg_arr))
    self.next_arrival=reg_arr[0]

  def arrival(self):
    #Schedule next arrival , new_arrival = previous_arrival + inter_arrival time of next customer  

    if pol_arr[self.p_count] < reg_arr[self.r_count]:
     
      
      self.next_arrival = pol_arr[self.p_count]
      self.p_count+=1

    else:
      
      self.next_arrival= reg_arr[self.r_count]
      self.r_count+=1 
    
    
    if self.server_status==0:   #server is idle
      self.server_status= 1    #make server BUSY
      delay=0.0            #so delay is zero
      self.total_delay += delay  
      self.num_of_delays +=1   #increase the number of customers delayed

      #schedule next departure, pop the first element of service_times list to get service time of this customer
      self.next_departure = self.clock+ self.service_times.pop(0)
      self.idle_time += self.clock - self.last_departure

  
    else:     #Server is BUSY
      #increase queue length, this customer will have to wait in the queue
      self.num_in_queue+=1
      
      #store the arrival time and service time of this customer in seperate lists
      if self.clock  == pol_arr[self.p2_count]:
        self.p2_count += 1
        
        self.times_of_arrival_in_queue.insert(0,self.clock)
        self.service_times_in_queue.append(self.service_times.pop(0))
      else:
            
        self.times_of_arrival_in_queue.append(self.clock) 
        self.service_times_in_queue.append(self.service_times.pop(0)) 

  def departure(self): ##depart from server
    self.last_departure = self.clock
    #check number of customers in the queue
    if self.num_in_queue==0:  #if no customer in the queue
      #make server IDLE 
      self.server_status= 0
      #schedule next departure= infinity
      self.next_departure= float('infinity')
    
    else: 
      #if queue not empty, pop one customer, decrease queue length
      self.num_in_queue-=1
      #AS FIFO, pop first arrival and service time from the queue. IF LIFO we have to pop last arrival and service time
      #For SJF, finf the index of minimum service time from  service_times_in_queue list.
      #Then pop the arrival of that index from times_of_arrival_in_queue for delay count and others. 

      
      arrival= self.times_of_arrival_in_queue.pop(0)

   
      delay= self.clock- arrival
      
      self.total_delay+=delay
      self.num_of_delays+=1

      self.next_departure = self.clock+ self.service_times_in_queue.pop(0)



      

s = SSQ()
s.start()

